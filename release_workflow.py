#!/usr/bin/env python3
"""
Complete release workflow: Version → Build → Release
Run this after your final commit to handle everything
"""
import re
import subprocess
import sys
import os
import json
import shutil
from datetime import datetime
from pathlib import Path

def debug_print(message):
    """Print debug messages clearly"""
    timestamp = datetime.now().strftime("%H:%M:%S")
    print(f"\n🔧 [{timestamp}] {message}")

def error_print(message):
    """Print error messages clearly"""
    timestamp = datetime.now().strftime("%H:%M:%S")
    print(f"\n❌ [{timestamp}] ERROR: {message}")

def success_print(message):
    """Print success messages clearly"""
    timestamp = datetime.now().strftime("%H:%M:%S")
    print(f"\n✅ [{timestamp}] {message}")

def get_current_version():
    """Get current version from setup.py"""
    debug_print("Reading current version from setup.py...")
    
    try:
        with open('setup.py', 'r') as f:
            content = f.read()
        
        version_match = re.search(r'version="([^"]+)"', content)
        if version_match:
            current_version = version_match.group(1)
            debug_print(f"Found current version: {current_version}")
            return current_version
        else:
            error_print("Could not find version in setup.py")
            return None
    except Exception as e:
        error_print(f"Could not read setup.py: {e}")
        return None

def increment_version(current_version, increment_type='patch'):
    """Increment version number"""
    debug_print(f"Incrementing version {current_version} ({increment_type})")
    
    try:
        parts = current_version.split('.')
        major, minor, patch = int(parts[0]), int(parts[1]), int(parts[2])
        
        if increment_type == 'major':
            major += 1
            minor = 0
            patch = 0
        elif increment_type == 'minor':
            minor += 1
            patch = 0
        else:  # patch
            patch += 1
        
        new_version = f"{major}.{minor}.{patch}"
        success_print(f"New version will be: {new_version}")
        return new_version
        
    except Exception as e:
        error_print(f"Could not increment version: {e}")
        return None

def update_version_in_files(new_version):
    """Update version in setup.py and installer script"""
    debug_print(f"Updating version to {new_version} in files...")
    
    files_updated = []
    
    # Update setup.py
    try:
        with open('setup.py', 'r') as f:
            content = f.read()
        
        updated_content = re.sub(r'version="[\d\.]+"', f'version="{new_version}"', content)
        
        with open('setup.py', 'w') as f:
            f.write(updated_content)
        
        files_updated.append('setup.py')
        debug_print("Updated setup.py")
        
    except Exception as e:
        error_print(f"Could not update setup.py: {e}")
        return []
    
    # Update or create installer script
    try:
        installer_script = create_installer_script(new_version)
        files_updated.append('installer_script.iss')
        debug_print("Created/updated installer_script.iss")
        
    except Exception as e:
        error_print(f"Could not create installer script: {e}")
    
    return files_updated

def create_installer_script(version):
    """Create Inno Setup installer script without database"""
    debug_print("Creating Inno Setup installer script...")
    
    # Check if your icon files exist
    icon_file = "./resources/ccell_icon.ico"
    logo_file = "./resources/ccell_logo_full.png"
    
    if not os.path.exists(icon_file):
        debug_print(f"WARNING: Icon file not found: {icon_file}")
        debug_print("Creating placeholder icon...")
        create_placeholder_icon()
    
    installer_content = f'''
; DataViewer Professional Installer Script
; Version {version}
; Auto-generated by release_workflow.py
; Database-free version - connects to remote Synology database

[Setup]
AppName=DataViewer
AppVersion={version}
AppPublisher=Charlie Becquet
AppPublisherURL=https://your-website.com
DefaultDirName={{autopf}}\\DataViewer
DefaultGroupName=DataViewer
AllowNoIcons=yes
OutputDir=installer_output
OutputBaseFilename=DataViewer_Setup_v{version}
SetupIconFile=resources\\ccell_icon.ico
Compression=lzma
SolidCompression=yes
WizardStyle=modern
ArchitecturesAllowed=x64
ArchitecturesInstallIn64BitMode=x64
MinVersion=6.1sp1
PrivilegesRequired=admin
UninstallDisplayIcon={{app}}\\DataViewer.exe

[Code]
var
  LicenseKeyPage: TInputQueryWizardPage;
  
function IsValidLicenseKey(Key: String): Boolean;
begin
  // Demo keys for testing
  Result := (Key = 'DEMO-1234-5678-ABCD') or 
            (Key = 'FULL-9876-5432-WXYZ') or
            (Key = 'DEV-AAAA-BBBB-CCCC') or
            (Length(Key) >= 16);  // Accept any 16+ char key for now
end;

procedure InitializeWizard;
begin
  LicenseKeyPage := CreateInputQueryPage(wpSelectDir,
    'License Key Required', 'Please enter your license key',
    'A valid license key is required to install this software.');
  LicenseKeyPage.Add('License Key:', False);
  LicenseKeyPage.Values[0] := 'DEMO-1234-5678-ABCD';  // Pre-fill demo key
end;

function NextButtonClick(CurPageID: Integer): Boolean;
begin
  Result := True;
  
  if CurPageID = LicenseKeyPage.ID then
  begin
    if not IsValidLicenseKey(LicenseKeyPage.Values[0]) then
    begin
      MsgBox('Invalid license key. Try: DEMO-1234-5678-ABCD', 
             mbError, MB_OK);
      Result := False;
    end;
  end;
end;

[Languages]
Name: "english"; MessagesFile: "compiler:Default.isl"

[Tasks]
Name: "desktopicon"; Description: "Create desktop shortcut"; GroupDescription: "Additional shortcuts:"; Flags: unchecked

[Files]
; Main executable
Source: "dist\\DataViewer\\DataViewer.exe"; DestDir: "{{app}}"; Flags: ignoreversion

; Include all the supporting files from the _internal directory
Source: "dist\\DataViewer\\_internal\\*"; DestDir: "{{app}}\\_internal"; Flags: ignoreversion recursesubdirs createallsubdirs

; Resources folder
Source: "resources\\*"; DestDir: "{{app}}\\resources"; Flags: ignoreversion recursesubdirs createallsubdirs

; Configuration file for database connection (optional)
Source: "config\\database_config.json"; DestDir: "{{app}}\\config"; Flags: ignoreversion skipifsourcedoesntexist

; REMOVED: Database file - now connects to remote Synology database

[Icons]
Name: "{{group}}\\DataViewer"; Filename: "{{app}}\\DataViewer.exe"
Name: "{{autodesktop}}\\DataViewer"; Filename: "{{app}}\\DataViewer.exe"; Tasks: desktopicon

[Run]
Filename: "{{app}}\\DataViewer.exe"; Description: "Launch DataViewer"; Flags: nowait postinstall skipifsilent
'''
    
    with open('installer_script.iss', 'w') as f:
        f.write(installer_content)
    
    success_print("Created installer script (database-free version)")
    return True

def create_placeholder_icon():
    """Create a basic icon from your PNG if .ico doesn't exist"""
    debug_print("Converting PNG to ICO...")
    
    try:
        from PIL import Image
        
        # Convert your ccell_icon.png to .ico
        png_path = "./resources/ccell_icon.png"
        ico_path = "./resources/ccell_icon.ico"
        
        if os.path.exists(png_path):
            img = Image.open(png_path)
            # Resize to standard icon sizes and save as ICO
            img.save(ico_path, format='ICO', sizes=[(256, 256), (128, 128), (64, 64), (32, 32), (16, 16)])
            debug_print(f"Converted {png_path} to {ico_path}")
        else:
            debug_print(f"PNG file not found: {png_path}")
            
    except ImportError:
        debug_print("PIL not available for icon conversion")
    except Exception as e:
        debug_print(f"Could not convert icon: {e}")

def build_executable():
    """Build the executable with PyInstaller"""
    debug_print("Building executable with PyInstaller...")
    
    # Clean previous builds
    debug_print("Cleaning previous builds...")
    for dir_name in ['build', 'dist', '__pycache__']:
        if os.path.exists(dir_name):
            shutil.rmtree(dir_name)
            debug_print(f"Removed {dir_name}")
    
    # PyInstaller command WITHOUT database inclusion
    cmd = [
        sys.executable, '-m', 'PyInstaller',
        '--onedir',
        '--windowed',
        '--name=DataViewer',
        '--icon=resources/ccell_icon.ico',
        '--add-data=resources;resources',
        
        
        '--collect-all=matplotlib',
        '--collect-all=PIL',           
        '--collect-all=pptx',  
        '--collect-all=pandas',
        '--collect-all=numpy',
        '--collect-all=logging',
        '--hidden-import=logging.handlers',
        
        # ONLY the essential hidden imports that might be missed
        '--hidden-import=matplotlib.backends.backend_tkagg',  # For GUI integration
        '--hidden-import=pkg_resources.py2_warn',
        
        '--exclude-module=tkinter.test',
        '--exclude-module=test',
        'main.py'
    ]
    
    debug_print("Running PyInstaller...")
    debug_print(f"Command: {' '.join(cmd)}")
    debug_print(f"Note: Database NOT included - will connect to remote database")
    
    try:
        result = subprocess.run(cmd, capture_output=True, text=True, timeout=6000)
        
        if result.returncode == 0:
            success_print("PyInstaller completed successfully")
            
            # Check if executable exists - FIXED for --onedir
            exe_path = 'dist/DataViewer/DataViewer.exe'  # Changed path for --onedir
            if os.path.exists(exe_path):
                size_mb = os.path.getsize(exe_path) / (1024 * 1024)
                success_print(f"Executable created: {exe_path} ({size_mb:.1f} MB)")
                
                # Show total directory size for --onedir
                total_size = sum(os.path.getsize(os.path.join(dirpath, filename))
                            for dirpath, dirnames, filenames in os.walk('dist/DataViewer')
                            for filename in filenames) / (1024 * 1024)
                success_print(f"Total application size: {total_size:.1f} MB")
                success_print("Database-free build - will connect to remote Synology database")
                return True
            else:
                error_print("Executable not found after build")
                # Debug: show what's actually in the dist directory
                debug_print("Contents of dist directory:")
                for item in os.listdir('dist'):
                    debug_print(f"  {item}")
                return False
            
    except subprocess.TimeoutExpired:
        error_print("PyInstaller timed out (10 minutes)")
        return False
    except Exception as e:
        error_print(f"PyInstaller error: {e}")
        return False

def cleanup_build_artifacts():
    """Clean up old build artifacts to prevent conflicts"""
    debug_print("Cleaning up old build artifacts...")
    
    artifacts_to_remove = [
        'installer_script.iss',
        'script_installer.iss', 
        'testing_gui_installer.iss',
        'build',
        'dist',
        '__pycache__',
        'installer_output'
    ]
    
    removed_items = []
    for item in artifacts_to_remove:
        if os.path.exists(item):
            try:
                if os.path.isdir(item):
                    shutil.rmtree(item)
                else:
                    os.remove(item)
                removed_items.append(item)
                debug_print(f"Removed: {item}")
            except Exception as e:
                debug_print(f"Could not remove {item}: {e}")
    
    if removed_items:
        success_print(f"Cleaned up build artifacts: {', '.join(removed_items)}")
    else:
        debug_print("No old build artifacts found")
    
    return True

def build_installer():
    """Build the installer with Inno Setup"""
    debug_print("Building installer with Inno Setup...")
    
        # Clean up any old installer scripts to avoid conflicts
    old_scripts = ['script_installer.iss', 'testing_gui_installer.iss']
    for old_script in old_scripts:
        if os.path.exists(old_script):
            os.remove(old_script)
            debug_print(f"Removed old installer script: {old_script}")

    # Check if Inno Setup is installed
    inno_paths = [
        "C:\\Program Files (x86)\\Inno Setup 6\\ISCC.exe",
        "C:\\Program Files\\Inno Setup 6\\ISCC.exe",
        "C:\\Program Files (x86)\\Inno Setup 5\\ISCC.exe"
    ]
    
    inno_exe = None
    for path in inno_paths:
        if os.path.exists(path):
            inno_exe = path
            break
    
    if not inno_exe:
        error_print("Inno Setup not found!")
        print("Install from: https://jrsoftware.org/isdl.php")
        print("Checked paths:")
        for path in inno_paths:
            print(f"  - {path}")
        return False
    
    debug_print(f"Found Inno Setup: {inno_exe}")
    
    # Create output directory
    os.makedirs('installer_output', exist_ok=True)
    
    try:
        result = subprocess.run([inno_exe, 'installer_script.iss'], 
                              capture_output=True, text=True, timeout=3000)
        
        if result.returncode == 0:
            success_print("Installer built successfully")
            
            # Find the installer file
            installer_files = list(Path('installer_output').glob('*.exe'))
            if installer_files:
                installer_path = installer_files[0]
                size_mb = installer_path.stat().st_size / (1024 * 1024)
                success_print(f"Installer: {installer_path} ({size_mb:.1f} MB)")
                return str(installer_path)
            else:
                error_print("Installer file not found")
                return None
        else:
            error_print("Inno Setup failed")
            print("STDOUT:", result.stdout)
            print("STDERR:", result.stderr)
            return None
            
    except Exception as e:
        error_print(f"Installer build error: {e}")
        return None

def cleanup_unwanted_folders():
    """Remove unwanted folders before packaging"""
    debug_print("Cleaning up unwanted folders before packaging...")
    
    unwanted_folders = [
        'scanned_forms',
        'training_data', 
        'plots',
        'data',
        'build',
        'dist',
        '__pycache__',
        'old_builds',
        'temp'
    ]
    
    removed_folders = []
    for folder in unwanted_folders:
        if os.path.exists(folder):
            try:
                shutil.rmtree(folder)
                removed_folders.append(folder)
                debug_print(f"Removed folder: {folder}")
            except Exception as e:
                debug_print(f"Could not remove {folder}: {e}")
    
    if removed_folders:
        success_print(f"Cleaned up: {', '.join(removed_folders)}")
    else:
        debug_print("No unwanted folders found to clean")
    
    # REMOVED: Database verification - no longer bundled
    success_print("Database-free build - will connect to Synology database at runtime")
    
    return True

def create_database_config():
    """Create sample database configuration file"""
    debug_print("Creating database configuration...")
    
    os.makedirs('config', exist_ok=True)
    
    config = {
        "database_type": "remote",
        "synology_settings": {
            "host": "your-synology-ip-or-hostname",
            "port": 5432,
            "database": "dataviewer",
            "username": "your_username",
            "password": "your_password",
            "connection_timeout": 30
        },
        "offline_mode": {
            "enabled": True,
            "cache_duration_hours": 24,
            "essential_functions_only": False
        },
        "fallback_behavior": "offline_mode"
    }
    
    config_path = 'config/database_config.json'
    with open(config_path, 'w') as f:
        json.dump(config, f, indent=2)
    
    debug_print(f"Created database config: {config_path}")
    debug_print("Edit this file to configure your Synology database connection")
    
    return config_path

def create_github_release(version, installer_path, release_notes=""):
    """Create GitHub release with large installer file"""
    debug_print("Creating GitHub release...")
    
    try:
        result = subprocess.run(['gh', '--version'], capture_output=True, check=True)
        debug_print("GitHub CLI found")
    except (subprocess.CalledProcessError, FileNotFoundError):
        debug_print("GitHub CLI not found - install from: https://cli.github.com/")
        return False
    
    try:
        tag_name = f"v{version}"
        title = f"DataViewer v{version}"
        
        if not release_notes:
            release_notes = f"Release v{version}\n\n- Bug fixes and improvements"
        
        # Create release with the large installer file
        cmd = [
            'gh', 'release', 'create', tag_name,
            installer_path,  # This will upload your large installer
            '--title', title,
            '--notes', release_notes
        ]
        
        debug_print(f"Creating release with large file: {installer_path}")
        
        result = subprocess.run(cmd, capture_output=True, text=True, check=True, timeout=6000)  # 100 minutes
        
        success_print("GitHub release created with large installer!")
        print(f"Release URL: {result.stdout.strip()}")
        return True
        
    except subprocess.CalledProcessError as e:
        error_print(f"GitHub release failed: {e.stderr}")
        return False

def main():
    """Main release workflow"""
    print("=" * 80)
    print("🚀 DataViewer RELEASE WORKFLOW")
    print("=" * 80)
    
    # Step 1: Get current version
    current_version = get_current_version()
    if not current_version:
        error_print("Cannot proceed without current version")
        return False
    
    # Step 2: Ask for new version
    print(f"\n📋 Current version: {current_version}")
    print("\nHow should I increment the version?")
    print("1. Patch (0.0.0 → 0.0.1) - Bug fixes")
    print("2. Minor (0.0.0 → 0.1.0) - New features") 
    print("3. Major (0.0.0 → 1.0.0) - Breaking changes")
    print("4. Custom version")
    
    choice = input("\nEnter choice (1-4): ").strip()
    
    if choice == '1':
        new_version = increment_version(current_version, 'patch')
    elif choice == '2':
        new_version = increment_version(current_version, 'minor')
    elif choice == '3':
        new_version = increment_version(current_version, 'major')
    elif choice == '4':
        new_version = input("Enter version (e.g., 0.0.1): ").strip()
    else:
        error_print("Invalid choice")
        return False
    
    if not new_version:
        error_print("Invalid version")
        return False
    
    # Step 3: Get release notes
    release_notes = input(f"\nEnter release notes for v{new_version} (optional): ").strip()
    
    # Step 4: Confirm
    print(f"\n📝 RELEASE SUMMARY:")
    print(f"   Current: {current_version}")
    print(f"   New: {new_version}")
    print(f"   Notes: {release_notes or 'Default notes'}")
    
    confirm = input(f"\n🚀 Build and release v{new_version}? (y/N): ").lower().strip()
    if confirm != 'y':
        print("❌ Release cancelled")
        return False
    
    # Execute the workflow
    print("\n" + "=" * 60)
    print("🏗️  STARTING BUILD PROCESS")
    print("=" * 60)
    
    if not cleanup_build_artifacts():
        error_print("Build artifact cleanup failed")
        return False

    # Step 4.5: Clean up unwanted folders FIRST
    if not cleanup_unwanted_folders():
        error_print("Pre-build cleanup failed")
        return False
    
    # Setep 4.6: Create database config
    create_database_config()
    
    # Step 5: Update version numbers
    updated_files = update_version_in_files(new_version)
    if not updated_files:
        error_print("Version update failed")
        return False
    
    # Step 6: Build executable
    if not build_executable():
        error_print("Executable build failed")
        return False
    
    # Step 7: Build installer
    installer_path = build_installer()
    if not installer_path:
        error_print("Installer build failed")
        return False
    
    # Step 8: Optional GitHub release
    github_release = input(f"\n🐙 Create GitHub release? (y/N): ").lower().strip()
    if github_release == 'y':
        create_github_release(new_version, installer_path, release_notes)
    
    # Step 9: Success!
    print("\n" + "=" * 80)
    print("🎉 SUCCESS! RELEASE COMPLETED")
    print("=" * 80)
    print(f"✅ Version: {new_version}")
    print(f"✅ Installer: {installer_path}")
    print(f"✅ Updated files: {', '.join(updated_files)}")
    
    print(f"\n📦 NEXT STEPS:")
    print(f"1. Test the installer: {installer_path}")
    print(f"2. Distribute to users")
    print(f"3. Update your website/documentation")
    
    # Test installer option
    test_installer = input(f"\n🧪 Test the installer now? (y/N): ").lower().strip()
    if test_installer == 'y':
        try:
            subprocess.Popen([installer_path], shell=True)
            print("🚀 Installer launched!")
        except Exception as e:
            error_print(f"Could not launch installer: {e}")
    
    return True

if __name__ == "__main__":
    success = main()
    if not success:
        sys.exit(1)