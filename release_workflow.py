#!/usr/bin/env python3
"""
Complete release workflow: Version → Build → Release
Run this after your final commit to handle everything
"""
import re
import subprocess
import sys
import os
import json
import shutil
from datetime import datetime
from pathlib import Path

def debug_print(message):
    """Print debug messages clearly"""
    timestamp = datetime.now().strftime("%H:%M:%S")
    print(f"\n🔧 [{timestamp}] {message}")

def error_print(message):
    """Print error messages clearly"""
    timestamp = datetime.now().strftime("%H:%M:%S")
    print(f"\n❌ [{timestamp}] ERROR: {message}")

def success_print(message):
    """Print success messages clearly"""
    timestamp = datetime.now().strftime("%H:%M:%S")
    print(f"\n✅ [{timestamp}] {message}")

def get_current_version():
    """Get current version from setup.py"""
    debug_print("Reading current version from setup.py...")
    
    try:
        with open('setup.py', 'r') as f:
            content = f.read()
        
        version_match = re.search(r'version="([^"]+)"', content)
        if version_match:
            current_version = version_match.group(1)
            debug_print(f"Found current version: {current_version}")
            return current_version
        else:
            error_print("Could not find version in setup.py")
            return None
    except Exception as e:
        error_print(f"Could not read setup.py: {e}")
        return None

def increment_version(current_version, increment_type='patch'):
    """Increment version number"""
    debug_print(f"Incrementing version {current_version} ({increment_type})")
    
    try:
        parts = current_version.split('.')
        major, minor, patch = int(parts[0]), int(parts[1]), int(parts[2])
        
        if increment_type == 'major':
            major += 1
            minor = 0
            patch = 0
        elif increment_type == 'minor':
            minor += 1
            patch = 0
        else:  # patch
            patch += 1
        
        new_version = f"{major}.{minor}.{patch}"
        success_print(f"New version will be: {new_version}")
        return new_version
        
    except Exception as e:
        error_print(f"Could not increment version: {e}")
        return None

def update_version_in_files(new_version):
    """Update version in setup.py and installer script"""
    debug_print(f"Updating version to {new_version} in files...")
    
    files_updated = []
    
    # Update setup.py
    try:
        with open('setup.py', 'r') as f:
            content = f.read()
        
        updated_content = re.sub(r'version="[\d\.]+"', f'version="{new_version}"', content)
        
        with open('setup.py', 'w') as f:
            f.write(updated_content)
        
        files_updated.append('setup.py')
        debug_print("Updated setup.py")
        
    except Exception as e:
        error_print(f"Could not update setup.py: {e}")
        return []
    
    # Update or create installer script
    try:
        installer_script = create_installer_script(new_version)
        files_updated.append('installer_script.iss')
        debug_print("Created/updated installer_script.iss")
        
    except Exception as e:
        error_print(f"Could not create installer script: {e}")
    
    return files_updated

def create_installer_script(version):
    """Create Inno Setup installer script with your icons"""
    debug_print("Creating Inno Setup installer script...")
    
    # Check if your icon files exist
    icon_file = "./resources/ccell_icon.png"
    logo_file = "./resources/ccell_logo.png"
    
    if not os.path.exists(icon_file):
        debug_print(f"WARNING: Icon file not found: {icon_file}")
        debug_print("Creating placeholder icon...")
        create_placeholder_icon()
    
    if not os.path.exists(logo_file):
        debug_print(f"WARNING: Logo file not found: {logo_file}")
    
    installer_content = f'''
; TestingGUI Professional Installer Script
; Version {version}
; Auto-generated by release_workflow.py

[Setup]
AppName=Standardized Testing GUI
AppVersion={version}
AppPublisher=Charlie Becquet
AppPublisherURL=https://your-website.com
DefaultDirName={{autopf}}\\TestingGUI
DefaultGroupName=Testing GUI
AllowNoIcons=yes
OutputDir=installer_output
OutputBaseFilename=TestingGUI_Setup_v{version}
SetupIconFile=resources\\ccell_icon.ico
Compression=lzma
SolidCompression=yes
WizardStyle=modern
ArchitecturesAllowed=x64
ArchitecturesInstallIn64BitMode=x64
MinVersion=6.1sp1
PrivilegesRequired=admin
UninstallDisplayIcon={{app}}\\TestingGUI.exe

; Simple license validation
[Code]
var
  LicenseKeyPage: TInputQueryWizardPage;
  
function IsValidLicenseKey(Key: String): Boolean;
begin
  // Demo keys for testing
  Result := (Key = 'DEMO-1234-5678-ABCD') or 
            (Key = 'FULL-9876-5432-WXYZ') or
            (Key = 'DEV-AAAA-BBBB-CCCC') or
            (Length(Key) >= 16);  // Accept any 16+ char key for now
end;

procedure InitializeWizard;
begin
  LicenseKeyPage := CreateInputQueryPage(wpSelectDir,
    'License Key Required', 'Please enter your license key',
    'A valid license key is required to install this software.');
  LicenseKeyPage.Add('License Key:', False);
  LicenseKeyPage.Values[0] := 'DEMO-1234-5678-ABCD';  // Pre-fill demo key
end;

function NextButtonClick(CurPageID: Integer): Boolean;
begin
  Result := True;
  
  if CurPageID = LicenseKeyPage.ID then
  begin
    if not IsValidLicenseKey(LicenseKeyPage.Values[0]) then
    begin
      MsgBox('Invalid license key. Try: DEMO-1234-5678-ABCD', 
             mbError, MB_OK);
      Result := False;
    end;
  end;
end;

[Languages]
Name: "english"; MessagesFile: "compiler:Default.isl"

[Tasks]
Name: "desktopicon"; Description: "Create desktop shortcut"; GroupDescription: "Additional shortcuts:"; Flags: unchecked

[Files]
; Main executable
Source: "dist\\TestingGUI.exe"; DestDir: "{{app}}"; Flags: ignoreversion

; Resources folder
Source: "resources\\*"; DestDir: "{{app}}\\resources"; Flags: ignoreversion recursesubdirs createallsubdirs

; Database file (IMPORTANT!)
Source: "dataviewer.db"; DestDir: "{{app}}"; Flags: ignoreversion; Check: FileExists(ExpandConstant('{{srcdir}}\\dataviewer.db'))

; Exclude unwanted folders explicitly
; NOTE: The above Source entries only include what we want

[Icons]
Name: "{{group}}\\Testing GUI"; Filename: "{{app}}\\TestingGUI.exe"
Name: "{{autodesktop}}\\Testing GUI"; Filename: "{{app}}\\TestingGUI.exe"; Tasks: desktopicon

[Run]
Filename: "{{app}}\\TestingGUI.exe"; Description: "Launch Testing GUI"; Flags: nowait postinstall skipifsilent
'''
    
    with open('installer_script.iss', 'w') as f:
        f.write(installer_content)
    
    success_print("Created installer script")
    return True

def create_placeholder_icon():
    """Create a basic icon from your PNG if .ico doesn't exist"""
    debug_print("Converting PNG to ICO...")
    
    try:
        from PIL import Image
        
        # Convert your ccell_icon.png to .ico
        png_path = "./resources/ccell_icon.png"
        ico_path = "./resources/ccell_icon.ico"
        
        if os.path.exists(png_path):
            img = Image.open(png_path)
            # Resize to standard icon sizes and save as ICO
            img.save(ico_path, format='ICO', sizes=[(256, 256), (128, 128), (64, 64), (32, 32), (16, 16)])
            debug_print(f"Converted {png_path} to {ico_path}")
        else:
            debug_print(f"PNG file not found: {png_path}")
            
    except ImportError:
        debug_print("PIL not available for icon conversion")
    except Exception as e:
        debug_print(f"Could not convert icon: {e}")

def build_executable():
    """Build the executable with PyInstaller"""
    debug_print("Building executable with PyInstaller...")
    
    # Clean previous builds
    debug_print("Cleaning previous builds...")
    for dir_name in ['build', 'dist', '__pycache__']:
        if os.path.exists(dir_name):
            shutil.rmtree(dir_name)
            debug_print(f"Removed {dir_name}")
    
    # Check if database exists and copy it to a safe location
    db_path = 'dataviewer.db'
    if os.path.exists(db_path):
        debug_print("Found dataviewer.db - will include in package")
    else:
        debug_print("WARNING: dataviewer.db not found!")
    
    # PyInstaller command with database inclusion
    cmd = [
        sys.executable, '-m', 'PyInstaller',
        '--onefile',
        '--windowed',
        '--name=TestingGUI',
        '--icon=resources/ccell_icon.ico',
        '--add-data=resources;resources',
        '--add-data=dataviewer.db;.',  # Add database to root of executable
        '--hidden-import=matplotlib.backends.backend_tkagg',
        '--hidden-import=PIL._tkinter_finder',
        '--hidden-import=pkg_resources.py2_warn',
        '--collect-all=matplotlib',
        '--collect-all=numpy',
        '--collect-all=pandas',
        'main.py'
    ]
    
    debug_print("Running PyInstaller...")
    debug_print(f"Command: {' '.join(cmd)}")
    
    try:
        result = subprocess.run(cmd, capture_output=True, text=True, timeout=600)
        
        if result.returncode == 0:
            success_print("PyInstaller completed successfully")
            
            # Check if executable exists
            exe_path = 'dist/TestingGUI.exe'
            if os.path.exists(exe_path):
                size_mb = os.path.getsize(exe_path) / (1024 * 1024)
                success_print(f"Executable created: {exe_path} ({size_mb:.1f} MB)")
                
                # Verify database is included
                debug_print("Verifying database inclusion...")
                return True
            else:
                error_print("Executable not found after build")
                return False
        else:
            error_print("PyInstaller failed")
            print("STDOUT:", result.stdout)
            print("STDERR:", result.stderr)
            return False
            
    except subprocess.TimeoutExpired:
        error_print("PyInstaller timed out (10 minutes)")
        return False
    except Exception as e:
        error_print(f"PyInstaller error: {e}")
        return False

def build_installer():
    """Build the installer with Inno Setup"""
    debug_print("Building installer with Inno Setup...")
    
    # Check if Inno Setup is installed
    inno_paths = [
        "C:\\Program Files (x86)\\Inno Setup 6\\ISCC.exe",
        "C:\\Program Files\\Inno Setup 6\\ISCC.exe",
        "C:\\Program Files (x86)\\Inno Setup 5\\ISCC.exe"
    ]
    
    inno_exe = None
    for path in inno_paths:
        if os.path.exists(path):
            inno_exe = path
            break
    
    if not inno_exe:
        error_print("Inno Setup not found!")
        print("Install from: https://jrsoftware.org/isdl.php")
        print("Checked paths:")
        for path in inno_paths:
            print(f"  - {path}")
        return False
    
    debug_print(f"Found Inno Setup: {inno_exe}")
    
    # Create output directory
    os.makedirs('installer_output', exist_ok=True)
    
    try:
        result = subprocess.run([inno_exe, 'installer_script.iss'], 
                              capture_output=True, text=True, timeout=300)
        
        if result.returncode == 0:
            success_print("Installer built successfully")
            
            # Find the installer file
            installer_files = list(Path('installer_output').glob('*.exe'))
            if installer_files:
                installer_path = installer_files[0]
                size_mb = installer_path.stat().st_size / (1024 * 1024)
                success_print(f"Installer: {installer_path} ({size_mb:.1f} MB)")
                return str(installer_path)
            else:
                error_print("Installer file not found")
                return None
        else:
            error_print("Inno Setup failed")
            print("STDOUT:", result.stdout)
            print("STDERR:", result.stderr)
            return None
            
    except Exception as e:
        error_print(f"Installer build error: {e}")
        return None

def cleanup_unwanted_folders():
    """Remove unwanted folders before packaging"""
    debug_print("Cleaning up unwanted folders before packaging...")
    
    unwanted_folders = [
        'scanned_forms',
        'training_data', 
        'plots',
        'data',
        'build',
        'dist',
        '__pycache__',
        'old_builds',
        'temp'
    ]
    
    removed_folders = []
    for folder in unwanted_folders:
        if os.path.exists(folder):
            try:
                shutil.rmtree(folder)
                removed_folders.append(folder)
                debug_print(f"Removed folder: {folder}")
            except Exception as e:
                debug_print(f"Could not remove {folder}: {e}")
    
    if removed_folders:
        success_print(f"Cleaned up: {', '.join(removed_folders)}")
    else:
        debug_print("No unwanted folders found to clean")
    
    # Verify database still exists
    if os.path.exists('dataviewer.db'):
        db_size = os.path.getsize('dataviewer.db') / 1024
        success_print(f"Database preserved: dataviewer.db ({db_size:.1f} KB)")
    else:
        error_print("WARNING: dataviewer.db not found!")
        return False
    
    return True

def create_github_release(version, installer_path, release_notes=""):
    """Create GitHub release (optional)"""
    debug_print("Creating GitHub release...")
    
    # Check if GitHub CLI is available
    try:
        result = subprocess.run(['gh', '--version'], capture_output=True, check=True)
        debug_print("GitHub CLI found")
    except (subprocess.CalledProcessError, FileNotFoundError):
        debug_print("GitHub CLI not found - skipping GitHub release")
        debug_print("Install from: https://cli.github.com/")
        return False
    
    try:
        tag_name = f"v{version}"
        title = f"TestingGUI v{version}"
        
        if not release_notes:
            release_notes = f"Release v{version}\n\n- Bug fixes and improvements"
        
        cmd = [
            'gh', 'release', 'create', tag_name,
            installer_path,
            '--title', title,
            '--notes', release_notes
        ]
        
        debug_print(f"Creating release: {' '.join(cmd)}")
        
        result = subprocess.run(cmd, capture_output=True, text=True, check=True)
        
        success_print("GitHub release created!")
        print(f"Release URL: {result.stdout.strip()}")
        return True
        
    except subprocess.CalledProcessError as e:
        error_print(f"GitHub release failed: {e.stderr}")
        return False

def main():
    """Main release workflow"""
    print("=" * 80)
    print("🚀 TESTINGGUI RELEASE WORKFLOW")
    print("=" * 80)
    
    # Step 1: Get current version
    current_version = get_current_version()
    if not current_version:
        error_print("Cannot proceed without current version")
        return False
    
    # Step 2: Ask for new version
    print(f"\n📋 Current version: {current_version}")
    print("\nHow should I increment the version?")
    print("1. Patch (3.0.0 → 3.0.1) - Bug fixes")
    print("2. Minor (3.0.0 → 3.1.0) - New features") 
    print("3. Major (3.0.0 → 4.0.0) - Breaking changes")
    print("4. Custom version")
    
    choice = input("\nEnter choice (1-4): ").strip()
    
    if choice == '1':
        new_version = increment_version(current_version, 'patch')
    elif choice == '2':
        new_version = increment_version(current_version, 'minor')
    elif choice == '3':
        new_version = increment_version(current_version, 'major')
    elif choice == '4':
        new_version = input("Enter version (e.g., 3.0.1): ").strip()
    else:
        error_print("Invalid choice")
        return False
    
    if not new_version:
        error_print("Invalid version")
        return False
    
    # Step 3: Get release notes
    release_notes = input(f"\nEnter release notes for v{new_version} (optional): ").strip()
    
    # Step 4: Confirm
    print(f"\n📝 RELEASE SUMMARY:")
    print(f"   Current: {current_version}")
    print(f"   New: {new_version}")
    print(f"   Notes: {release_notes or 'Default notes'}")
    
    confirm = input(f"\n🚀 Build and release v{new_version}? (y/N): ").lower().strip()
    if confirm != 'y':
        print("❌ Release cancelled")
        return False
    
    # Execute the workflow
    print("\n" + "=" * 60)
    print("🏗️  STARTING BUILD PROCESS")
    print("=" * 60)
    
    # Step 4.5: Clean up unwanted folders FIRST
    if not cleanup_unwanted_folders():
        error_print("Pre-build cleanup failed")
        return False
    
    # Step 5: Update version numbers
    updated_files = update_version_in_files(new_version)
    if not updated_files:
        error_print("Version update failed")
        return False
    
    # Step 6: Build executable
    if not build_executable():
        error_print("Executable build failed")
        return False
    
    # Step 7: Build installer
    installer_path = build_installer()
    if not installer_path:
        error_print("Installer build failed")
        return False
    
    # Step 8: Optional GitHub release
    github_release = input(f"\n🐙 Create GitHub release? (y/N): ").lower().strip()
    if github_release == 'y':
        create_github_release(new_version, installer_path, release_notes)
    
    # Step 9: Success!
    print("\n" + "=" * 80)
    print("🎉 SUCCESS! RELEASE COMPLETED")
    print("=" * 80)
    print(f"✅ Version: {new_version}")
    print(f"✅ Installer: {installer_path}")
    print(f"✅ Updated files: {', '.join(updated_files)}")
    
    print(f"\n📦 NEXT STEPS:")
    print(f"1. Test the installer: {installer_path}")
    print(f"2. Distribute to users")
    print(f"3. Update your website/documentation")
    
    # Test installer option
    test_installer = input(f"\n🧪 Test the installer now? (y/N): ").lower().strip()
    if test_installer == 'y':
        try:
            subprocess.Popen([installer_path], shell=True)
            print("🚀 Installer launched!")
        except Exception as e:
            error_print(f"Could not launch installer: {e}")
    
    return True

if __name__ == "__main__":
    success = main()
    if not success:
        sys.exit(1)